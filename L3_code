#!/usr/bin/python3

import RPi.GPIO as GPIO
from time import sleep

KP1 = 0.5 #0.50 #0.1
KP2 = 0.5 #0.50 #0.1
KD1 = 0.50 #0.1
KD2 = 0.50 #0.1
KI1 = 0.0
KI2 = 0.0
TARGET = 1000
SAMPLETIME = 0.1

# Configuration des broches pour les encodeurs
ENCODER1_CHANNEL_A = 6
ENCODER2_CHANNEL_A = 19

# Configuration des broches pour le contrôle des moteurs
MOTOR1_PWM_PIN = 18
MOTOR1_DIR_PIN1 = 23
MOTOR1_DIR_PIN2 = 24

MOTOR2_PWM_PIN = 21
MOTOR2_DIR_PIN1 = 20
MOTOR2_DIR_PIN2 = 16

# Initialisation de la bibliothèque RPi.GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
# Configuration des broches d'entrée pour les encodeurs
GPIO.setup(ENCODER1_CHANNEL_A, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(ENCODER2_CHANNEL_A, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# Configuration des broches pour le contrôle des moteurs
GPIO.setup(MOTOR1_PWM_PIN, GPIO.OUT)
GPIO.setup(MOTOR1_DIR_PIN1, GPIO.OUT)
GPIO.setup(MOTOR1_DIR_PIN2, GPIO.OUT)

GPIO.setup(MOTOR2_PWM_PIN, GPIO.OUT)
GPIO.setup(MOTOR2_DIR_PIN1, GPIO.OUT)
GPIO.setup(MOTOR2_DIR_PIN2, GPIO.OUT)

# Variables pour stocker les compteurs d'impulsions des encodeurs
encoder1_counter = 0
encoder2_counter = 0
count1 = 0
count2 = 0

# Creation d'une liste des pins pour chaque moteur pour compacter la suite du code
Pins = [[MOTOR1_PWM_PIN, MOTOR1_DIR_PIN1, MOTOR1_DIR_PIN2], [MOTOR2_PWM_PIN,MOTOR2_DIR_PIN1, MOTOR2_DIR_PIN2]]

# Initialisation PWM
motor1_pwm = GPIO.PWM(MOTOR1_PWM_PIN, 100)
motor2_pwm = GPIO.PWM(MOTOR2_PWM_PIN, 100)
#motor1_pwm.start(60)
#motor2_pwm.start(60)
def avancer(moteurNum) :
   GPIO.output(Pins[moteurNum - 1][1], GPIO.HIGH)
   GPIO.output(Pins[moteurNum - 1][2], GPIO.LOW)
   #print("Moteur", moteurNum, "tourne dans le sens 1.")
def reculer(moteurNum) :
   GPIO.output(Pins[moteurNum - 1][1], GPIO.LOW)
   GPIO.output(Pins[moteurNum - 1][2], GPIO.HIGH)
  # print("Moteur", moteurNum, "tourne dans le sens 2.")
def arret(moteurNum) :
   GPIO.output(Pins[moteurNum - 1][1], GPIO.LOW)
   GPIO.output(Pins[moteurNum - 1][2], GPIO.LOW)
 #  print("Moteur", moteurNum, "arret.")
def arretComplet() :
   GPIO.output(Pins[0][1], GPIO.LOW)
   GPIO.output(Pins[0][2], GPIO.LOW)
   GPIO.output(Pins[1][1], GPIO.LOW)
   GPIO.output(Pins[1][2], GPIO.LOW)
#   print("Moteurs arretes.")
   arretComplet()


# Fonctions d'interruption pour détecter les impulsions des encodeurs
def encoder1_callback(channel):
    global encoder1_counter, count1
    encoder1_counter += 1
    count1 += 1
    #print("Encoder 1 interrupt detected")

def encoder2_callback(channel):
    global encoder2_counter, count2
    encoder2_counter += 1
    count2 += 1
    #print("Encoder 2 interrupt detected")

# Configuration des interruptions matérielles pour les encodeurs
GPIO.add_event_detect(ENCODER1_CHANNEL_A, GPIO.RISING, callback=encoder1_callback, bouncetime=2)
GPIO.add_event_detect(ENCODER2_CHANNEL_A, GPIO.RISING, callback=encoder2_callback, bouncetime=2)

def control_motors_Av(m1_speed, m2_speed, e1_error, e2_error, e1_prev_error, e2_prev_error, e1_sum_error, e2_sum_error):
    global e1_adj, e2_adj
    
 
    e1_adj = (e1_error * KP1) + (e1_prev_error * KD1) + (e1_sum_error * KI1)
    e2_adj = (e2_error * KP2) + (e2_prev_error * KD2) + (e2_sum_error * KI2)

    m1_speed += e1_adj
    m2_speed += e2_adj

    # Assurez-vous que les vitesses des moteurs restent dans les limites (0, 100)
    m1_speed = min(max(m1_speed, 0), 100)
    m2_speed = min(max(m2_speed, 0), 100)

# Commande des moteurs ici en ajustant le PWM et les directions
    if m1_speed >= 0:
        motor1_pwm.start(m1_speed)
        avancer(1)
    else:
        arret(1)

    if m2_speed >= 0:
        motor2_pwm.start(m2_speed)
        avancer(2)
    else:
        arret(2)

    return m1_speed, m2_speed


def control_motors_Ar(m1_speed, m2_speed, e1_error, e2_error, e1_prev_error, e2_prev_error, e1_sum_error, e2_sum_error):
    global e1_adj, e2_adj
    e1_adj = (e1_error * KP1) + (e1_prev_error * KD1) + (e1_sum_error * KI1)
    e2_adj = (e2_error * KP2) + (e2_prev_error * KD2) + (e2_sum_error * KI2)

    m1_speed += e1_adj
    m2_speed += e2_adj

    # Assurez-vous que les vitesses des moteurs restent dans les limites (0, 100)
    m1_speed = min(max(m1_speed, 0), 100)
    m2_speed = min(max(m2_speed, 0), 100)

    # Commande des moteurs ici en ajustant le PWM et les directions
    if m1_speed >= 0:
        motor1_pwm.start(m1_speed)
        avancer(1)
    else:
        arret(1)

    if m2_speed >= 0:
        motor2_pwm.start(m2_speed)
        reculer(2)

    else:
        arret(2)

    return m1_speed, m2_speed

def control_motors_Dr(m1_speed, m2_speed, e1_error, e2_error, e1_prev_error, e2_prev_error, e1_sum_error, e2_sum_error):
    global e1_adj, e2_adj
    
    e1_adj = (e1_error * KP1) + (e1_prev_error * KD1) + (e1_sum_error * KI1)
    e2_adj = (e2_error * KP2) + (e2_prev_error * KD2) + (e2_sum_error * KI2)

    m1_speed += e1_adj
    m2_speed += e2_adj

    # Assurez-vous que les vitesses des moteurs restent dans les limites (0, 100)
    m1_speed = min(max(m1_speed, 0), 100)
    m2_speed = min(max(m2_speed, 0), 100) # Commande des moteurs ici en ajustant le PWM et les directions
    
    if m1_speed >= 0:
        motor1_pwm.start(m1_speed)
        avancer(1)

    else:
        arret(1)

    if m2_speed >= 0:
        motor2_pwm.start(m2_speed)
        reculer(2)

    else:
        arret(2)

    return m1_speed, m2_speed


def control_motors_Gch(m1_speed, m2_speed, e1_error, e2_error, e1_prev_error, e2_prev_error, e1_sum_error, e2_sum_error):
    global e1_adj, e2_adj
    
    e1_adj = (e1_error * KP1) + (e1_prev_error * KD1) + (e1_sum_error * KI1)
    e2_adj = (e2_error * KP2) + (e2_prev_error * KD2) + (e2_sum_error * KI2)

    m1_speed += e1_adj
    m2_speed += e2_adj

    # Assurez-vous que les vitesses des moteurs restent dans les limites (0, 100)
    m1_speed = min(max(m1_speed, 0), 100)
    m2_speed = min(max(m2_speed, 0), 100) # Commande des moteurs ici en ajustant le PWM et les directions
    
    if m1_speed >= 0:
        motor1_pwm.start(m1_speed)
        avancer(1)

    else:
        arret(1)

    if m2_speed >= 0:
        motor2_pwm.start(m2_speed)
        avancer(2)

    else:
        arret(2)

    return m1_speed, m2_speed



e1_sum_error = 0
e2_sum_error = 0
e1_prev_error = 0
e2_prev_error = 0
m1_speed = 100  # Vitesse initiale (0-100)
m2_speed = 100  # Vitesse initiale (0-100)
n=1
x=0

try:
    while x<1:
        # Lire les compteurs d'impulsions des encodeurs
        e1_value = encoder1_counter
        e2_value = encoder2_counter

        # Réinitialiser les compteurs d'impulsions pour le prochain échantillon
        encoder1_counter = 0
        encoder2_counter = 0

        e1_error = e1_value - e2_value
        e2_error = e2_value - e1_value

 # Réinitialiser les compteurs d'impulsions pour le prochain échantillon
        encoder1_counter = 0
        encoder2_counter = 0

        e1_error = e1_value - e2_value
        e2_error = e2_value - e1_value  
    # Vérifiez si la différence d'erreur est supérieure à 2
        if abs(e1_error - e2_error) > 2:
    # Vérifiez si la différence d'erreur est supérieure à 2
           if e2_error > e1_error:
             print("L'erreur est supérieur à 2")
        # Ajustez la vitesse du moteur associé à e1
             motor1_pwm.start(m1_speed)
        # Assurez-vous que la vitesse reste dans les limites acceptables
             m1_speed = max(m1_speed, 0)  # Assurez-vous que la vitesse ne devienne pas négative
           else:
        # Ajustez la vitesse du moteur associé à e2
             motor2_pwm.start(m2_speed) #m2_speed -= 1  # Par exemple, réduisez la vitesse de 1
        # Assurez-vous que la vitesse reste dans les limites acceptables
             m2_speed = max(m2_speed, 0)  # Assurez-vous que la vitesse ne devienne pas négative

        m1_speed, m2_speed = control_motors_Av(m1_speed, m2_speed, e1_error, e2_error, e1_prev_error, e2_prev_error, e1_sum_error, e2_sum_error)
        
        print(" Tic_1 {} Tic_2 {}".format(count1, count2))
       # print("{} error1 {} error2 {}".format(n, e1_error, e2_error))
       # print("e1.adj {} e2.adj {} m1 {} m2 {}".format(e1_adj, e2_adj, m1_speed, m2_speed))
        n+=1
        e1_prev_error = e1_error
        e2_prev_error = e2_error

        e1_sum_error += e1_error
        e2_sum_error += e2_error
        
        arret(1)
        arret(2)
        sleep(0.2)

    while (count1<1822):
        m1_speed, m2_speed = control_motors_Dr(m1_speed, m2_speed, e1_error, e2_error, e1_prev_error, e2_prev_error, e1_sum_error, e2_sum_error)

        arret(1)
        arret(2)
        sleep(0.2)

        while (count1<2900):
          m1_speed, m2_speed = control_motors_Av(m1_speed, m2_speed, e1_error, e2_error, e1_prev_error, e2_prev_error, e1_sum_error, e2_sum_error)
        #sleep(SAMPLETIME)  
        x+=2
        motor1_pwm.stop() 
        motor2_pwm.stop()

except KeyboardInterrupt:
    # Arrêtez les moteurs et nettoyez les broches GPIO lorsqu'une interruption clavier est détectée
    motor1_pwm.stop()
    motor2_pwm.stop()
    GPIO.cleanup()

